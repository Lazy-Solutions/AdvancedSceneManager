<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/README.md -->


# Advanced Scene Manager

### Guides

> Guides are handwritten articles to help you up to speed in working with ASM.

[Quick start](guides/Quick%20start.md)\
[Updating ASM](guides/Updating.md)\
[Videos](<guides/Videos.md>)\
[Scene Manager Window](<guides/Scene manager window.md>)\
[Common questions](<guides/Common questions.md>)

[Profiles](guides/Profiles.md)\
[Scenes](guides/Scenes.md)\
[Standalone scenes](<guides/Standalone scenes.md>)\
[Scene collections](<guides/Scene collections.md>)\
[Loading screens](<guides/Loading screens.md>)\
[Splash screens](<guides/Splash screens.md>)

**API**:\
[An overview of ASM API structure](<guides/An overview of ASM API structure.md>)\
[Scene Manager](<guides/Scene manager.md>)\
[Callbacks](<guides/Callbacks.md>)\
[Scene operations](<guides/Scene operations.md>)\
[Scene loaders](<guides/Scene loaders.md>)

**Plugin support**:\
[Scene bindings](<guides/Scene bindings.md>)\
[Netcode](<guides/Netcode.md>)\
[Addressables](<guides/addressables.md>)

**Misc**:\
[Scene Helper](<guides/Scene helper.md>)\
[In-game toolbar](<guides/In-game toolbar.md>)\
[Cross-scene references](<guides/Cross-scene references.md>)\
[Finding ASM assets](<guides/Finding asm assets.md>)\
[Utility Functions](<guides/ASMUtilityFunctions.md>)

### Example projects

[Level select](https://github.com/Lazy-Solutions/example.asm.level-select)\
[Preloading](https://github.com/Lazy-Solutions/example.asm.preloading)\
[Streaming](https://github.com/Lazy-Solutions/example.asm.streaming)\
[Netcode](https://github.com/Lazy-Solutions/example.asm.netcode)

### Example scripts

A couple example scripts are included in ASM, you can import them as a upm sample from the package manager.

### API reference

> The API reference is autogenerated from sandcastle comments (C# method comments).

[Start browsing](api/readme.md)

### Patches can be downloaded from:

**Github releases**

[Github releases](https://github.com/Lazy-Solutions/AdvancedSceneManager/releases/latest) hosts the latest .unitypackage for download.

**Discord**

Discord provides notifications for patches, you'll be taken to github releases when pressing link.

**From inside unity**

ASM has a built in update check. You'll be notified when a patch has been released via a notification in the ASM window, press it to view patch notes. You'll be prompted to import .unitypackage after pressing download button (you will need to wait a moment as the package is downloading).

<script id="embedai" src="https://embedai.thesamur.ai/embedai.js" data-id="advanced-scene-manager"></script>



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/ASMUtilityFunctions.md -->

![](../image/ASMUtilityFunctionsWindow.png)
![](../image/ASMUtilityButton.png)

## ASMUtilityFunction

ASMUtilityFunction provides quick, easily accessible utility functions within the Advanced Scene Manager (ASM). These functions are designed to be flexible and extendable, allowing users to create custom utilities that integrates with ASM.

### Extending ASMUtilityFunction

To add a custom utility function, create a new class that inherits from ASMUtilityFunction. Override the necessary properties and methods to define the utility’s name, description, grouping, and functionality. Here’s a basic example:

```csharp
public class CustomUtilityFunction : ASMUtilityFunction
{
    public override string Name => "My Custom Utility";
    public override string Description => "A description of what this utility does.";
    public override string Group => "Custom Group";

    public override void OnInvoke(ref VisualElement optionsGUI)
    {
        VisualElement visualElement = new();

        Button button = new Button(() => { 
            // Define the button's functionality here
        });

        visualElement.Add(button); 

        optionsGUI = visualElement;
    }
}
```

This new Function will automatically be found by the Utility Window


<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/An overview of ASM API structure.md -->

# An overview of ASM API structure

ASM is structured into three levels:
1. Surface level
2. Intermediary level
3. Core level

<br/>

## Surface level:
The surface level is most common level to interact with ASM.

It includes:
* `SceneCollection.Open()`*, and similar.*
* `Scene.Open()`*, and similar.*
* `SceneHelper.Open()`*, and similar.*

<br/>

## Intermediary level:
The intermediary level tracks the open state of [scenes](Scenes.md) and [collections](Scene%20collections.md), and also verifies whatever a scene actually should be opened or not (ASM does not support duplicate instances of a scene).

Can be accessed using:\
`SceneManager.runtime`

The surface level API is are mostly just proxy calls to the intermediary one:

```csharp
public Scene : ASMModel
{
	...
	public SceneOperation Open() => SceneManager.runtime.Open(this);
	...
}
```

<br/>

## Core level:
This is the core of ASM. It deals with the actual loading and unloading of scenes.

`SceneOperation`

<br/>

[Scene operation](Scene%20operations.md) basically takes a list of [scenes](Scenes.md) to close, and a list of scenes to open, then closes / opens them. Scenes specified to close will always be closed before any scenes are opened (except loading screen).

Scene operation also manages loading screens and will automatically open a specified loading screen before it begins to unload scenes. If a loading screen was opened, then it will be automatically closed after scenes have been loaded.

Scenes in unity cannot be loaded in parallel, due to this scene operations will usually run in a queue, some exceptions exist (like loading screens and finish preload).

An operation can be started in code by using either of these two:\
`SceneOperation.Queue()`\
`SceneOperation.Start() //Ignores queue`

```csharp
public Scene[] scenesToOpen;
public Scene loadingScene;

public void OnButtonClick() =>
	SceneOperation.Queue().
		Open(sceneToOpen).
		Close(SceneManager.openScenes).
		With(loadingScene);
```

### Fluent API

As you can also see above, SceneOperation supports a fluent API, allowing for things like this:

```csharp

SceneManager.runtime.Open(sceneToOpen).Close(closeAlreadyOpenScene).With(loadingScreenScene);

//This is functionally equivalent to above
sceneToOpen.Open().Close(closeAlreadyOpenScene).With(loadingScreenScene);

```

> You should have a look at `.With(..)` using intellisense, or in the [api documentation](../api/Core.SceneOperation.md), it has many overloads for various different things.



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Callbacks.md -->

# Scene callbacks

## Interfaces

Sometimes you may want to run some initialization code when a scene opens, before loading screen is closed. Scene callbacks helps you do that. Scene callbacks must be implemented by a MonoBehaviour, and that script must then be attached to a scene, ASM will then invoke the script when that scene is opened. Callbacks for scene close also exist.

Collection callbacks are called for all scenes that are contained within the collection that is opened, or closed.

Open callbacks:

* `ISceneOpen` (void)
* `ISceneOpenCoroutine` (coroutine)
* `ISceneOpenAwaitable` (awaitable, *UNITY_2023_1_OR_NEWER*)
* `ICollectionOpen` (void)
* `ICollectionOpenCoroutine` (coroutine)
* `ICollectionOpenAwaitable` (awaitable, *UNITY_2023_1_OR_NEWER*)

Close callbacks:

* `ISceneClose` (void)
* `ISceneCloseCoroutine` (coroutine)
* `ISceneCloseAwaitable` (awaitable, *UNITY_2023_1_OR_NEWER*)
* `ICollectionClose` (void)
* `ICollectionCloseCoroutine` (coroutine)
* `ICollectionCloseAwaitable` (awaitable, *UNITY_2023_1_OR_NEWER*)

> Note that these callbacks may sometimes not be called when loading scenes outside of ASM. This is because they are invoked by ASM SceneOperation directly, and if SceneOperation is not opening the scenes, then no callbacks. Some exceptions exist.

## Order

* Loading screen open (_if one specified_)
* `ICollectionClose` (_if collection specified_)
* `ISceneClose`
* Unload scenes
* Load scenes
* Preload scene (_if one defined_)
* `ISceneOpen`
* `ICollection` open (_if collection specified_)
* Hide loading screen (_if one specified_)

## Example

```csharp
public class LogOnSceneCallback : MonoBehaviour, ISceneOpen, ISceneClose
{
    public void OnSceneOpen()
    {
        Debug.Log(this.ASMScene().name + " opened");
    }
    public void OnSceneClose()
    {
        Debug.Log(this.ASMScene().name + " closed");
    }
}

public class Promotion : MonoBehaviour, ICollectionOpenAsync, ICollectionCloseAsync
{
    //TODO: Remove when you want a promotion
    public IEnumerator OnCollectionOpen(SceneCollection collection)
    {
        yield return new WaitForSecondsRealtime(60);
    }
    public IEnumerator OnCollectionClose(SceneCollection collection)
    {
        yield return new WaitForSecondsRealtime(60);
    }
}
```

## Events

There are also several C# events, which are fire and forget, scene operation will not wait for them, you can register listeners for them anywhere.

```csharp
//Invoked by unity when editor starts / script recompile
[InitializeOnLoad]
static void OnLoad
{
	SceneManager.runtime.collectionOpened += (c) => Log(c, "opened");
	SceneManager.runtime.collectionClosed += (c) => Log(c, "closed");

	SceneManager.runtime.sceneOpened += (s) => Log(s, "opened");
	SceneManager.runtime.sceneClosed += (s) => Log(s, "closed");
	SceneManager.runtime.scenePreloaded += (s) => Log(s, "preloaded");
}

void Log(Scene scene, string action)
{
	Debug.Log($"{scene.name} {action}.");
}

void Log(SceneCollection collection, string action)
{
	Debug.Log($"{collection.title} {action}.");
}
```

# Event callback API

The event callback API can be used to listen for events in code. Designed mimic Unity UI Toolkit event callbacks. All events are available in either global or operation specific API.

```csharp
public Scene scene1;
public Scene scene2;
```

**Operation specific events**

```csharp
//Only called for this specific scene operation
public void OperationSpecificEvents()
{
	scene1.Open().
		RegisterCallback<SceneOpenEvent>(e => 
			Debug.Log("Scene opened: " + e.scene), When.After);
}
```

**Global events**

```csharp
//Called for every operation until domain reload, or explicitly unregistered
//Phase events are available for operation specific API as well  
public static void RegisterGlobalEvents()
{
	//Phase events
	//Are always called
	SceneManager.runtime.RegisterCallback<StartPhaseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<EndPhaseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<LoadingScreenOpenPhaseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<SceneClosePhaseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<SceneOpenPhaseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<ScenePreloadPhaseEvent>(Callback);

	//Conditional events.
	//Called for each individual scene or collection, if any
	SceneManager.runtime.RegisterCallback<ScenePreloadEvent>(Callback);
	SceneManager.runtime.RegisterCallback<SceneOpenEvent>(Callback);
	SceneManager.runtime.RegisterCallback<SceneCloseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<CollectionOpenEvent>(Callback);
	SceneManager.runtime.RegisterCallback<CollectionCloseEvent>(Callback);
}

private static void Callback(SceneOperationEventBase e)
{

	//e.when can be used if When was not specified when registering
	//e.operation can be used to get a reference to the operation. Can sometimes be null depending on event.

	if (e is SceneEvent sceneEvent)
		Debug.Log($"[{e.GetType().Name}]: {sceneEvent.scene}");
	else if (e is CollectionEvent collectionEvent)
		Debug.Log($"[{e.GetType().Name}]: {collectionEvent.collection}");
	else
		Debug.Log($"[{e.GetType().Name}]");

}
```

**Blocking operations**

```csharp
//Waits 5 seconds before opening scene
public void CloseSceneThenOpenOtherWithDelay()
{
	scene1.Close().Open(scene2).RegisterCallback<SceneOpenEvent>(e =>
	{
		if (e.scene == scene2) //Not needed here, but shown for demostration purposes
			e.WaitFor(Awaitable.WaitForSecondsAsync(5)); 
	});
}
```



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Common questions.md -->

# Common questions

## What is the fallback scene

The fallback scene is a scene ASM uses to simplify the scene management, unity does not allow for all scenes to be unloaded, which means we need to have a check for this every time we unload a scene, we decided it would be simpler to just keep a special scene in memory since this ensures that the scene can be unloaded, and we do not have to worry about forgetting to have a check beforehand, as ASM used to have issues with this.

The second reason is to prevent potential flickering during startup which would occur with a non-empty scene. [Startup scene](Scene%20manager%20window.md#startup-page) can be overridden in settings, this scene may also be used as fallback scene, but note that ASM could switch to regular fallback scene at any point after startup. Fallback scene will be always sorted to at the top of build settings for this reason.

> Please note that that overriding startup scene is an advanced use-case that should not be used unless actually needed, you probably want to use [startup collections](Scene%20collections.md) and [startup standalone scenes](Standalone%20scenes.md) instead.

## Build settings list

ASM will automatically manage the build list for you.

Manually modifying the build scenes list is still supported though.\
When adding a scene, ASM will add it to [standalone](Standalone%20scenes.md), and vice versa for removing a scene. Removing scenes that are contained within a collection is not supported though, and will just not work.

Scenes cannot be reordered manually.

## Event methods

Some methods in ASM are prefixed with "\_", this is due to name conflicts as [UnityEvent](https://docs.unity3d.com/Manual/UnityEvents.html) does not support methods with return values.

## Do I need to add anything to .gitignore?

You should always gitignore assets as required also by Unity, To ignore ASM and other asset of ours, Add the folders found in YourProject/Packages/... (Not In Assets folder). The only thing would be `<project root>/UserSettings/` but that should be ignored for unity project anyways. Default [unity .gitignore](https://github.com/github/gitignore/blob/main/Unity.gitignore) already contains it.

## Compilation issues after installing ASM

This is something we cannot really do much about. Sometimes unity compiles propertly and all works, sometimes it doesn't.

There are two ways to solve this problem:
1. Restart editor.
2. Right click on AdvancedSceneManager folder and choose 'Reimport' - sometimes this works, sometimes it doesn't.

If it still won't compile, then thats a bug, you'll need to report that to us over at:\
[Discord - Lazy Solutions](https://discord.gg/upfgXPxFnw)

## What is the difference between patches and asset store updates?

Asset store updates happens irreguarly, and has been properly tested to be stable, both by us and Unity. Validation process usually takes a few days.

Patches on the other hand have quicker turn around, we can push instantly, but may be less stable. We always test what we changed in a patch, and do our best to test ASM in general, but we do not garuantee that ASM is 100% stable. If you do get a bug though, you can just let us know, and we'll push a new patch fixing it as soon as we are able.

### Patches can be downloaded from:
#### Github
[Github releases](https://github.com/Lazy-Solutions/AdvancedSceneManager/releases/latest) hosts .unitypackage for download.

#### Inside of unity:
![](https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/2.0/image/scene-manager-window-menu.png)

The checkmark in the top section of the image indicates no updates are available. But it will update depending on whatever a patch is available. Pressing it when there is no patch available will re-check for one.



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/CoroutineUtility.md -->

## CoroutineUtility
Run coroutines detached from MonoBehaviours and scenes which makes working with coroutines in certain circumstances a lot easier.\
Supports [Editor Coroutines](https://docs.unity3d.com/Manual/com.unity.editorcoroutines.html).

```csharp
void Start()
{

    //Unity, attached with script and will stop when
    //scene or object is unloaded.
    StartCoroutine(Coroutine());

    //Coroutine Utility, runs detached from script and
    //won't stop when scene or object is unloaded
    var coroutine = Coroutine().StartCoroutine();

    //Pauses coroutine (automatically yields null until coroutine.Resume() is called)
    coroutine.Pause();
    coroutine.Resume();

    //Stop coroutine
    coroutine.Stop();

}

async Start() {
    // Unity's Awaitable class
    Awaitable<bool> coroutine = OnOpen().StartCoroutineAsAwaitable();
    await coroutine;

    // Does not work with Unity Web (WebGL)
    Task coroutine = OnOpen().StartCoroutineAsTask();
    await coroutine;

    // Does not work with Unity Web (WebGL)
    GlobalCoroutine coroutine = OnOpen().StartCoroutine();
    await coroutine;
}

IEnumerator Coroutine()
{
    ...
}
```
</br>

## MainThreadUtility
Provides functionality to invoke code on main thread. Useful when using tasks or threading, and you need to perform action on main thread.

```csharp
async Task Background_Task()
{

    //Time class cannot be accessed from a thread
    //other than the main thread
    var currentTime = MainThreadUtility.Invoke(() => Time.realtimeSinceStartup);

    //Do something with time...

}
```



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Cross-scene references.md -->

# Cross-scene references

Cross scene references is one of those small things that should be supported by Unity, but just isn't. ASM implements this feature and may be enabled in [settings](Scene%20manager%20window.md#scene-loading-page).

> Note that due to the nature of working around Unity's attempts to prevent cross-scene references, and certain usage non-public APIs (*Unity event support*), it is hacky at best, so please test your games thoroughly if you decide to use them.

![](../image/cross-scene-references.png)
![](../image/cross-scene-reference-example.png)

A Guid Reference script will be automatically added to both objects, this is what makes the entire thing work. You may use these on your own if you wish, have a look at [GuidReferenceUtility](../api/Utility.GuidReferenceUtility.md).

When an object has a reference to another scene, a link icon will be displayed next to both objects in the hierarchy, pressing the link icon will select the connected object.

Pressing the link on the scene field will open the cross-scene reference debugger, 
which will list all references stored in ASM, and will hopefully help in figuring out if and why a reference is broken. You may also delete references from here, doing so will set the Variable field to null.

![](../image/cross-scene-debugger.png)

Note that you may receive warnings from unity, these are safe to ignore. We have tried our best to hide as many these warnings as possible, but Unity will not relent.

![](../image/cross-scene-reference-warning.png)

## Start, Awake, OnEnable

Due to the way scenes are loaded in unity, ASM cannot restore cross-scene references until after the scene is fully loaded, `Start()`, `Awake()`, and `OnEnable()` are called before the first possible time to restore them.

You may however make use of [ASM scene callbacks](Callbacks.md), cross-scene references are guaranteed to have been restored by the time they are called.




<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Finding asm assets.md -->

# Finding ASM assets

You can find scenes, collections and profiles very easily, like so:

```csharp
var profile = Profile.Find("name_or_id");

var scene = Scene.Find("name_path_or_id");
var gameplayScenes = Scene.Find(s => s.name.Contains("gameplay"));
var openScenes1 = SceneUtility.FindOpen("name_path_or_id");
var openScenes2 = SceneUtility.FindOpen(s => s.name.contains("gameplay"));

var collectionScene1 = SceneCollection.Find("name_or_id").Find("name_id_or_path");
var collectionScene1 = SceneCollection.Find("name_or_id").FirstOrDefault(s => s.name.Contains("gameplay")); //Linq

//Checks only active profile
var collection1 = SceneCollection.Find("name_title_or_id"); 

//Checks all profiles
var collection2 = SceneCollection.Find("name_title_or_id", activeProfile: false); 
```

> Notice: The method documentation (sandcastle comments / triple slash comments) are currently slightly wrong, as the methods were updated, but not comments. This will be fixed in a future update.



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/In-game toolbar.md -->

# In-game toolbar

The in-game toolbar provides some debugging tools, especially useful in builds, relating to scene management.

#### How do I use it?
The easiest way is to add it to [standalone](Standalone%20scenes.md), then add a [scene binding](Scene%20bindings.md) to it. This is done by default when creating a new profile, assuming [Input system](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/index.html) is installed *(Scene bindings only support [InputSystem](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/index.html))*. It is bound to tab, by default.

#### What can I do with it?

![](../image/in-game-toolbar.png)

The in-game toolbar allows you to:
* Restart the game.
* Re-open currently open [collection](Scene%20collections.md).
* Quit game.
* See if ASM is currently working (see [ASM scene operations](Scene%20operations.md)).
* List open [scenes](Scenes.md).




<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Loading screens.md -->

# Loading screens

This guide explains how to use and customize loading screens in **Advanced Scene Manager (ASM)**.

> **Want to perform actions as a scene has loaded, but _**while**_ the loading screen is visible?**\
Use ASM's callback interfaces like `ISceneOpen` or `ICollectionOpen`. These let you trigger logic once the scene is loaded—**but before** the loading screen closes.
> 
> Perfect for deferred UI setups, data initialization, or network checks. See Callbacks for full interface details.

## Ways to Open a Loading Screen

1. **Opening a Collection**
   
When a scene collection is opened (as defined in the collection menu), ASM will open a loading screen automatically if one is defined, or fall back to the default defined on the profile.
```csharp
collection.Open();
```
    
2. **Using SceneOperation.With(Scene loadingScene) (Fluent API)**
    
Override the default loading screen for this operation using the fluent API:
```csharp
collection.Open().With(loadingScene: loadingScene); // Overrides loading screen for this operation
```
    
3. **Using LoadingScreenUtility**
   
Manually open and close a loading screen:
```csharp
var operation = LoadingScreenUtility.OpenLoadingScreen(loadingScene);
yield return operation;

action.Invoke();

yield return LoadingScreenUtility.CloseLoadingScreen(operation.value);
```

Or use a helper method:
```csharp
yield return LoadingScreenUtility.DoAction(loadingScene, action);
```

## Custom Loading Screens

Create a custom script by inheriting from `AdvancedSceneManager.Callbacks.LoadingScreen`:

```csharp
public class MyLoadingScreen : LoadingScreen
{
    public Slider slider;
    public CanvasGroup fadeGroup;
    public float fadeDuration = 0.5f;

    public override IEnumerator OnOpen() => FadeIn();
    public override IEnumerator OnClose() {
        if (slider) slider.gameObject.SetActive(false);
        yield return FadeOut();
    }

    public override void OnProgressChanged(ILoadProgressData progress) {
        if (slider) slider.value = progress.value;
    }

	protected IEnumerator FadeIn()
	{

		fadeBackground.color = color; //Color can be changed when using FadeUtility methods

		if ((fadeInDurationOverride ?? fadeDuration) > 0)
			yield return fadeGroup.Fade(1, fadeInDurationOverride ?? fadeDuration);
		else
			fadeGroup.alpha = 1;

	}

	protected IEnumerator FadeOut()
	{
		yield return fadeGroup.Fade(0, fadeDuration);
	}
        
}
```

Once ready, place it in a scene and assign it in:

- A collection’s **loading screen** override
    
- Or the **ASM Settings** under **Scene Loading** to make it the default

> **Note:** For a scene to be recognized as a loading screen, ASM relies on a serialized flag inside the scene file. This flag is set by the `LoadingScreen` base class:
> ```csharp
> [SerializeField]
> private bool isLoadingScreen = true;
> 
> public virtual void OnValidate()
> {
>     if (!isLoadingScreen)
>         isLoadingScreen = true;
> }
> ```
> This flag (`isLoadingScreen: 1`) must be written into the scene file on disk. That only happens if the scene is marked as dirty and saved afterward. So if your custom loading screen doesn't show up in loading scene pickers, try modifying and saving the scene again.
> 
> Additionally, ASM maintains a cached `isLoadingScene` flag on its internal Scene Scriptable Objects. This cache may become outdated. You can manually refresh all scene metadata by pressing the **reload** button next to the loading scene pickers in the UI. This forces ASM to scan scene files on disk and update flags accordingly.


## Progress Reporting with `ILoadProgressData`

Prefer implementing:

```csharp
public override void OnProgressChanged(ILoadProgressData progress) { ... }
```

### Built-in types:

#### SceneLoadProgressData

Used internally when loading scenes.

```csharp
Scene.Open().DisableProgressReporting(); // Disable if needed
```

Properties:

- `value`: Progress (0-1)
    
- `scene`: Scene being loaded
    
- `operation`: Scene operation data
    

#### ✅ MessageLoadProgressData

Used for simple message + progress scenarios.

```csharp
LoadingScreenUtility.ReportProgress(new MessageLoadProgressData("Loading...", 0.5f));
```

#### ✅ Custom Progress Types

```csharp
public readonly struct MyCustomProgress : LoadProgressData 
{
    public float value { get; }
}

LoadingScreenUtility.ReportProgress(new MyCustomProgress());
```

## Default Loading Screens

ASM includes several default loading screen scenes.

### Where to find them:

These are now part of a **UPM sample**. Import them:

- From **Package Manager** under "Advanced Scene Manager"
    
- Or via the **Import** button in the ASM defaults collection UI

> After importing, they will appear in: `Assets/Samples/Advanced Scene Manager/<version>/Default ASM Screens/`

> ⚠️ **Important:**
> 
> If you re-import the default scenes, the asset ID of each scene will change. This breaks any existing references in ASM profiles or collections. Always double-check your assigned loading scenes after re-importing.
> 
> The default scenes rarely change, so only re-import if you’re encountering an issue or need to restore them.

You can also access them programmatically:
```csharp
SceneManager.assets.defaults.fade //Gets the default fade scene
```



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Netcode.md -->

# Netcode

This example was built on NGO(Netcode for game objects) 1.2.0, things may have changed.

### Intro

There are 2 ways to work with ASM and NGOs.
First is to make use of the Netcode built-in scene manager, this will give us
NetworkManager, Events, Scene and object synchronization, and all nice things.

The second would be to disable the built-in scene manager, this would give you a lot
more freedom and flexibility, but at the cost of having to implement everything yourself.
That means you need to make a new NetworkManager, NetworkSceneManager,
Network sync, and NetworkObject.

Unity gave us the option to disable scene management but not individual systems.
Meaning you have to make your own scene manager with their built-in functions, which
in my opinion, is NOT a custom scene manager. Alternatively, remake all from scratch, it
is entirely up to you. Rebuilding would give you the flexibility to completely take
advantage of ASM but is very time-consuming.

This example is for the first option with the netcode plugin from ASM, If you are going
for option 2, I wish you luck.

Rules to follow

1. In NGO the client syncs the scenes, meaning the ASM workflow will not be
   applied. It’s the NGO workflow that loads the scene, you will utilize ASM on the
   server side.
2. ASM still works if you wish to work with offline scenes on the client side. Like
   loading a UI pause screen during gameplay for example. Or return to the main
   menu. It’s just the netcode scenes that will be loaded by netcode and not ASM.
3. Preload, Collection loading screen, and the active scene will not be
   synchronized, you have to create the sequence yourself, an example of this can
   be found in “ConnectionManager.cs” where we have a sequence for client
   connect and host connect. And it’s simply because the client syncs the scene not
   load it themself.
4. This plugin only syncs the scenes marked as Netcode, if you wish to change this
   rule, assign a new validator to
   “networkManager.SceneManager.VerifySceneBeforeLoading”, this is the main
   method for handling which scenes sync.
5. Method marked as netcode cannot be loaded when offline.
   This project is a good start, but just an example. Feel free to use it. Feel free to
   experiment, this is not a “must do” guide.



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Profiles.md -->

## Profiles

Profiles in ASM are used to define and switch between distinct scene configurations. Each profile contains:

- Scene Collections
    
- Dynamic Collections
    
- Standalone Scenes
    
- Default Loading Screen
    
- Splash Screen
    
- Configuration settings from the settings popup
    

Profiles are selected in the bottom-left corner of the Scene Manager window, via the profile picker.
![](../image/profile-popup.png)
### Default Profile

A default profile can be configured in the Editor settings. This profile is selected automatically if the active profile is null, after domain reload. ASM stores the active profile per-user in UserSettings, allowing each user to work with a different profile. The default profile mainly ensures that a consistent fallback is used if no profile has been explicitly selected yet.

### Forced Profile

A profile can also be forced in the Editor settings. This is mostly useful in team environments where one person manages ASM, and others shouldn't need to interact with it. When a forced profile is set, ASM overrides the user-specific profile setting and enforces a single consistent profile across the project, offering a more reliable alternative to relying on the default profile selection behavior.

### Build Profile

The build profile is the profile ASM uses when building the game. It determines which collections, scenes, and settings are included during the build process.


<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Quick start.md -->

<!--
---
layout: default
title: Quick Start Guide
---
-->

<meta http-equiv="refresh" content="0; url=Quick%20start.html">

# Quick start

<br/>

**Install ASM from Package Manager:**

To begin, open Unity and navigate to the Window menu. From there, open the package manager and search for Advanced Scene Manager", install it. Wait for unity to compile.

![package-manager](../image/package-manager.png)

**Open Scene Manager Window:** 

Access the Scene Manager window through the File menu and choose "Scene Manager..."

![file-menu](../image/file-menu.png)

**Create Profile:** 

Within the Scene Manager window, press the profile selector, in the lower left corner. Create a new profile by clicking on the current profile name or "create", if none exists, or "none", if profiles do exist, but none are selected.

![profile-picker](../image/profile-picker.png)

**Default profile:** 

The default profile has two collections "Startup (persistent)" and "Main Menu". Press the menu button on the collection headers, and observe that both collections are set to open at startup. On Startup collection, also observe the "Open persistent" toggle in the "Open options" further down.

![collection-menu-button](../image/collection-menu-button.png)

![startup-option](../image/startup-option.png)

![collection-open-option](../image/collection-open-option.png)

**Create Scenes:** 

Create two scenes like you normally would in unity, name them "Startup" and "Main Menu".

**Import Scenes into ASM:** 

Following scene creation, a notification will appear in the Scene Manager window. Click on the notification to open the import popup. Confirm that both scenes are toggled and press "Import".

![import-popup](../image/import-popup.png)

**Assign Scenes to Collections:** 

Within the Scene Manager, drag the scenes into their respective collections and drop them on the "drop area" to add them.

![scene-drop-area](../image/scene-drop-area.png)

**Press Play in Scene Manager:** 

Located at the top left of the Scene Manager window, press the Play button. Watch as ASM enters play mode and plays the default ASM splash screen, then fades out, opens scenes, fades in, the main menu scene should be active in hierarchy.

![play-button](../image/play-button.png)

![asm-splash-screen](../image/asm-splash-screen.png)

**Levels**

Now, lets create some levels, create two collections, "Level 1" and "Level 2". This time, instead of creating scenes in project window, lets add a scene field in each collection, by pressing the "+" in the collection header. Then press the create scene button to the right of the object field. Name the scenes the same as their collections. Lets also create a UI scene, and assign it to both level collections.

![create-scene-button](../image/create-scene-button.png)

**Main menu**

Now, lets open the main menu scene by pressing the open scene button or the open collection button. Style your main menu as you want, but add two buttons, "Level 1" and "Level 2". Select the button for level 1 and add a On Click () handler to the Button script, then hold and drag from the collection header for "Level 1", this will start a drag drop for that collection, drop it on the button click handler. Then select SceneCollection > _Open (bool). Then do the same for the second level collection. Then add a "Quit" button, for this On Click () handler, drag and drop the scene helper button instead, which is to the left of the new collection button. Then select ASMSceneHelper > Quit ().

> The collection open toggle is not important right now, but it specifies whatever all scenes on a collection should open, since some scenes may be flagged to not open automatically, only explicitly.

![button-click-collection-open](../image/button-click-collection-open.png)


![scene-helper-button](../image/scene-helper-button.png)


![button-click-quit](../image/button-click-quit.png)

**Play**

Now when you press the play button, you'll be taken to the main menu in the same manner as before, but you can now press a level button to be taken to that level. To go back to main menu, press the ASM play button once more, and ASM will restart (but skip splash screen). Now press the quit button, and ASM will fade out, then exit play mode.

> Note that you do not have to use quit function to quit your game, it is merely an convenience feature.


**Using Start() and Awake()**

Start and awake are still Unity callbacks, so they still functions as normal. But it's important to be aware that these callbacks are often called before ASM has finished it's loading jobs. Therefor if you need all scenes in a collection to be loaded before you initialize code or run logic, use our callbacks. And so ASM does not always support opening scenes or collections (especially collections), in these callbacks. A lot of new users seem to miss this, so please also read this section: [scene callbacks](Callbacks.md). (This is often used when developing with ASM.) 

> A common misuse is to instantiate gameobjects in Start, resulting in the object being loaded into the wrong scene, as ASM has not yet updated the active scene, then it's common to use ICollectionOpen to instantiate.

**Done**

And with that, we're done! Enjoy working on your game instead of getting bogged down in scene management!



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Scene bindings.md -->

# Scene bindings

Scene bindings are used to open collections or scenes through a key or button binding.

[Collections](Scene%20collections.md) can be bound using the [collection popup](Scene%20manager%20window.md#collection-popup).\
[Standalone scenes](Standalone%20scenes.md) can be bound using the scene menu.

![](../image/scene-bindings.png)

Interaction can be used to specify when the collection or scene should close.
* Open: Only open, don't close.
* Hold: Keep open when button held down, then close on release.
* Toggle: Toggle scene open or closed on button down.




<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Scene collections.md -->

# Scene collections

A scene collection, *more commonly referred to as just collection*, is a collection of scenes that will all be opened at the same time.

![](../image/scene-manager-window-collections.png)

When a collection closes, all currently open non-persistent scenes will be closed, unless the closing collection was opened as additive. When opened additively, a collection will only close its own scenes, assuming the current normally opened collection does not manage it.

Collections support opening [loading screens](Loading%20screens.md) before opening or closing, and will, by default, use the default loading screen, which is defined in the [settings](Scene%20manager%20window.md#scene-loading-page).

Each scene collection can be configured with startup options that determine whether it should be opened when the game starts. 

These options include:  
**Open**: The collection will always open on startup.  
**Auto**: The collection will open if no other collections are set to Open, and it is the first Auto collection in the list.  
**Do Not Open**: The collection will not open automatically.

Note that unless a scene or collection is marked as persistent, it will be closed if multiple collections are set to open at startup. Only the last collection will remain *open*.

## Dynamic collections

Dynamic collections automatically gather all scenes located within a specified folder and its subfolders. These scenes are automatically included in builds, even if they aren't explicitly imported into ASM. Dynamic collections are useful for bulk-managing a group of related scenes that should always be available.

The folder path used by a dynamic collection can be configured in the collection settings popup. The contents of a dynamic collection are updated automatically based on the current contents of the specified folder.

## Standalone collection

The standalone collection contains all standalone scenes — scenes that are not part of any other collection but should still be available in the build. Scenes can be added or removed manually, and you can define their persistence or load behavior individually.

Standalone scenes are often used for UI overlays, pause menus, debug tools, or other utility content that doesn't fit neatly into a specific collection. They also support input bindings, allowing scenes to be opened or closed in response to user input, such as Escape or Tab, making them ideal for toggleable UI like pause screens or scoreboards.

Standalone scenes can also be configured to open automatically during startup.

## ASM defaults collection

The ASM Defaults collection includes all default scenes provided by ASM, such as splash screens and loading screens. The scenes are provided via a UPM samples package and can be imported either from the Package Manager window or using the "Import" button in the UI of the collection itself.

## Creating collections

### In the UI

To create a new collection in the UI, open the Scene Manager window and use the **New collection** split button in the footer. Clicking the main part of the button will create a regular scene collection. Clicking the dropdown arrow opens a menu where you can create a dynamic collection or one based on a template. Scene collection templates are also managed from this menu.

### In code

Collections can also be created through code using the `Profile` API. The currently active profile is available via `SceneManager.profile`.

You can create collections using:
```csharp
SceneManager.profile.CreateCollection(); // Creates a new collection with the title 'New collection'
SceneManager.profile.CreateCollection("My Collection"); // Creates one with a specific title
SceneManager.profile.CreateCollection(myTemplate); // Creates a collection from a template
SceneManager.profile.CreateDynamicCollection("Assets/MyFolder", "My Dynamic Collection"); // Creates a dynamic collection
```

To access existing collections:
```csharp
var collections = SceneManager.profile.collections;
var dynamicCollections = SceneManager.profile.dynamicCollections;
var standalone = SceneManager.profile.standaloneScenes;
var defaults = SceneManager.profile.defaultASMScenes;
var allCollectionsInProject = SceneManager.assets.collections;
```

Collections can also be found or accessed using the find API:
```csharp
var found = SceneCollection.Find("Main Menu"); // Match by title or ID (active profile by default)

if (SceneCollection.TryFind("Main Menu", out var menuCollection))
{
    Debug.Log("Found collection: " + menuCollection);
}
```



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Scene helper.md -->

# Scene helper

The scene helper is a [ScriptableObejct](https://docs.unity3d.com/Manual/class-ScriptableObject.html) that is provided to make it easier to open collections or scenes in [UnityEvent](https://docs.unity3d.com/Manual/UnityEvents.html). Most methods found on scene helper can also be found on scene and collections, but it might be easier to find the methods you want on scene helper, since there is less methods unintentionally listed when selecting one.

![](../image/button-click-quit.png)

Scene helper can be found on the scene manager window, next to the new collection button. Just drag from the button to gain a reference.

![](../image/scene-helper-and-new-collection.png)

It can also be accessed in code:\
`AdvancedSceneManager.Models.ASMSceneHelper.instance`



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Scene loaders.md -->

# Scene Loaders

Scene loaders are what Scene operations use to actually load or unload a scene. They modularize scene loading, allowing ASM to support different loading mechanisms — whether runtime, editor, addressables, or even multiplayer (Netcode).

There are four scene loaders included with ASM:

- **RuntimeSceneLoader** — uses [UnityEngine.SceneManagement](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html). Always active in play mode.
    
- **EditorSceneLoader** — uses [UnityEditor.SceneManagement.EditorSceneManager](https://docs.unity3d.com/ScriptReference/SceneManagement.EditorSceneManager.html). Used outside of play mode.
    
- **AddressablesSceneLoader** — uses Unity's [Addressables](https://docs.unity3d.com/Manual/com.unity.addressables.html) system for loading scenes marked as addressable.
    
- **NetcodeSceneLoader** — used when working with Unity's [Netcode for GameObjects](https://docs-multiplayer.unity3d.com/netcode/current/about/), syncing scenes across clients and servers.
    

> Runtime and Editor scene loaders are **global** — they match all scenes unless overridden. Addressables and Netcode scene loaders are **non-global** — only apply to scenes flagged for them.

To flag a scene to use a specific loader, use:

```csharp
Scene.SetSceneLoader<YourLoader>();
```

You’ll see the result of this in the scene popup (UI) as a toggle if the loader defines `sceneToggleText`.

![](../image/addressable-toggle.png)

## Scene Loader API

To create a custom scene loader, inherit from:

```csharp
AdvancedSceneManager.Core.SceneLoader
```

Example:

```csharp
class MyCustomLoader : SceneLoader
{
    public override bool activeOutsideOfPlayMode => true;
    public override string sceneToggleText => "Use custom loader";
    public override bool isGlobal => false;

    public override IEnumerator LoadScene(Scene scene, SceneLoadArgs e)
    {
        Debug.Log("Loading scene: " + scene.name);
        yield return new WaitForSeconds(1f); // Simulate load
        e.SetCompleted(e.GetOpenedScene());
    }

    public override IEnumerator UnloadScene(Scene scene, SceneUnloadArgs e)
    {
        Debug.Log("Unloading scene: " + scene.name);
        yield return new WaitForSeconds(1f); // Simulate unload
        e.SetCompleted();
    }
}
```

To register your loader:

```csharp
[RuntimeInitializeOnLoadMethod]
static void OnLoad()
{
    SceneManager.runtime.AddSceneLoader<MyCustomLoader>();
}
```

You can also unregister it with:

```csharp
SceneManager.runtime.RemoveSceneLoader<MyCustomLoader>();
```

## Indicators and Toggles

Custom scene loaders can define:

```csharp
public override Indicator indicator => new()
{
    text = "",
	useFontAwesome = true
};
```

This will appear as an icon next to scenes using this loader.
![](../image/addressables-scene-indicator.png)

## Loader Selection Logic

ASM uses the following logic to choose a scene loader:

1. If a scene is flagged for a loader via `SetSceneLoader<T>()`, that loader is used.
    
2. If multiple loaders match, the first one registered takes priority.
    
3. If no match is found, the global loaders are used (Runtime or Editor).


<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Scene manager window.md -->

# Scene manager window

The scene manager window is the front-end for ASM. It can be used to manage [collections](Scene%20collections.md), [scenes](Scenes.md), and behavior of ASM.

![](../image/scene-manager-window.png)

The scene manager window can be opened through:

![](../image/scene-manager-menu.png)

## Main view
### Header

![](../image/scene-manager-window-header.png)

The header contains the following, in order, left to right:
* Play button, enters play mode and runs startup process, as if we're running in a build.
* Overview button, opens a popup presenting all scenes in project.
* Settings button, displays the [settings popup](#settings-popup).
* Menu button, displays the [menu popup](#menu) with some useful tools.

### Collections and scenes

![](../image/scene-manager-window-collections.png)

The collections and scene list contain... collections and scenes!

#### Collection header
The elements in the [collection](Scene%20collections.md) header are as follows, in order, left to right:
* Reorder collections.
* Enter play mode and open collection when startup process done *(startup process when using this button can be turned off in settings)*.
* Open collection.
* Open / close collection as additive.
* Collection title
* Collection menu button, opens a popup containing settings for the given collection.
* Remove button, removes the collection.
* Add scene field button.

> Note that some elements may be hidden, check settings for more.

#### Scene field
The elements on the [scene](Scenes.md) field are as follows, in order, left to right:
* Reorder scenes.
* Open scene.
* Open / close scene as additive.
* Scene selector (could also be called scene field, conflicting terms here).
* Indicators *(not visible in image above)*.
* Scene menu button, opens a popup containing settings for the scene, some global, some specific to parent collection.
* Delete button, deletes the scene field.

> Note the terms *Remove* and *Delete*, Remove is used to describe a reversible action here, whereas delete will not provide option to undo.

> Collection headers and scenes may be dragged to gain a drag drop reference.

### Dynamic collections and scenes

![](../image/scene-manager-window-dynamic-collections.png)

Dynamic collections are collections that contain scenes that do not fit within a normal collection, but are still supposed to be included in build. This is needed because ASM manages the build scene list (adding a scene to list manually just causes ASM to add it to standalone collection).

The **[standalone](Standalone%20scenes.md)** is a special dynamic collection, it allows you to add scene fields and modify its scene list, it also cannot be deleted. 

The **ASM Defaults** dynamic collection on the other hand is a normal dynamic collection, it takes a path to a folder, and gathers all scenes found within its subfolders. The folder path can be configured in the collection popup.

> The stars in the image above are persistent indicators, these scenes will not be closed automatically by ASM, only when user requests it *(or by scene bindings in this case, see scene popup for more information)*.

### Footer

![](../image/scene-manager-window-footer.png)

The footer contains, in order, left to right:
* [Profile](Profiles.md) selector, opens a popup where a profile can be selected, or created.
* [Scene helper](Scene%20helper.md) button, provides an easy way to gain a drag drop reference to scene helper scriptable object, which can be used in UI button click, for example.
* New collection split button, pressing dropdown section opens a popup where you can create a dynamic collection, or create normal collection from a template.

## Collection popup

![](../image/scene-manager-window-collection-popup.png)

The collection popup contains:
* **Title**
* **User data**, which can be used to associate custom scriptable object with collection, retrievable by `SceneCollection.UserData<T>()` or `SceneCollection.UserData()`. They can implement scene callbacks as well.
* **Startup**, determines if collection should be opened by ASM during startup. Auto means ASM will open collection if it is first collection in list, and and no other collection is specified as *open*.
* **Loading priority**, when not set to *auto*, ASM will automatically set corresponding [ThreadPriority](https://docs.unity3d.com/ScriptReference/ThreadPriority.html) when scene operation begins, on collection open / close, and then reset it when done.
* **Loading screen usage**, determines if default loading screen should be used, or if it should be overridden, or disabled.
* **[Loading scene](Loading%20scenes.md)**, determines loading scene to use when above is set to override.
* **Unload unused assets**, if true then ASM will automatically call [Resources.UnloadUnusedAssets](https://docs.unity3d.com/ScriptReference/Resources.html) when scene operation, on collection open / close, is done.
* **Open persistent**, determines if all scenes within should be opened as persistent.
* **Active scene**, specifies scene to activate when opening collection.
* **Binding**, specifies a input binding that can be used to open collection when pressed *(only available when [InputSystem](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/index.html) is installed)*.
* **Interaction**, specifies whatever binding will automatically close collection.
	* **Open**, do not close, only open.
	* **Hold**, close collection when binding is released.
	* **Toggle**, close collection on next press.
* **Open additive**, opens the collection as additive when using binding.

# Scene popup

![](../image/scene-manager-window-scene-popup.png)

The scene popup contains:
* **Do not open automatically**, specifies whatever this scene should remain closed when collection is opened, use this when you want to open scene yourself, but still want scene associated with collection. *This is a collection specific setting, and is saved on parent collection.*
* **Keep scene open on collection close (persistent)**, specifies that this scene should not be closed by ASM automatically, only when user explicitly closes scene directly.
* **When collection opens scene, but it is already open**, specifies what ASM should do when scene is already open when a collection opens it.
* **Open scene outside of play-mode automatically**, specifies that ASM should open this scene additively, *outside of play-mode*, when another scene opens.

> *Collection specific options* section contains settings that are related to the current parent collection only, when assigning scene to multiple collections, this section will be different depending on collection. **All other sections are global.**
# Menu popup

![](../image/scene-manager-window-menu.png)

The menu popup contains:
* **Current version**, version check and link to view available patches *(patches are .UnityPackage(s) that we provide outside of the normal unity asset store updates, that fixes bugs, and even sometimes provide new features, but could potentially be unstable, we try our hardest though!)*.
* **Dev build**, provides a quick way to build your project during development. Folder can be specified using folder button, and profiler can be attached using bug button. Press play button to build and run.
* **Documentation**, provides shortcuts to local docs, and online docs.
* **Contact**, ASM appreciates your feedback, bug reports and suggestions alike! Also contains a button to view example projects.
# Settings popup

![](../image/settings-popup.png)

The settings popup contains the configration options of ASM. Settings are categorized into multiple pages:
* **Startup**, contains settings related to the startup process, or more simply, what scenes or collections should be opened when game starts.
* **Scene loading**, contains settings that define how ASM should behave when loading scenes.
* **Assets**, contains settings relating to ASM assets, like ASM scenes, collections and profiles.
* **Editor**, contains settings that define how ASM behaves in the editor.
* **Netcode** *(not visible in image above, as it is only shown when [netcode for gameobjects](https://docs-multiplayer.unity3d.com/netcode/current/about/) package is installed)*, contains settings relating to our netcode plugin.

## Startup page

![](../image/settings-startup-page.png)

The startup page contains:
* **Splash screen**, displays a splash screen when game starts.
* **Loading screen**, displays a splash screen during the startup process *(this is useful since its common to open multiple collections for example, standalone scenes may also be opened)*.
* **Create temp camera during startup**, if there is no camera during startup, one will be created, this may sometimes cause issues, so you may want to disable this then.
* **Startup scene**, this is the first scene that will be opened, it should be mostly empty, since otherwise you'll get flickering during startup. This should only be used in very rare use-cases, normally you'd just use collections and standalone scenes flagged to open during startup.
## Scene loading page

![](../image/settings-scene-loading-page.png)

The scene loading page contains:
* **Default loading screen**, this is the loading screen that will be used when opening or closing collections, if none is explicitly defined in the collection settings.
* **Reverse unload order, when closing collections**, specifies that scenes should unload bottom up (when viewed in scene hierarchy).
* **Prevent duplicate scene operations**, sometimes, such as when player is spamming a UI button that will open a scene / collection, you probably do not want duplicate operations, this attempts to prevent that. *Note that a better solution may still be to disable buttons or similar, since that would be more fool-proof.*
## Assets page

![](../image/settings-assets-page.png)

The assets page contains:
* **Scene import option**, specifies whatever scenes created *normally* will be automatically imported into ASM. Non-normal would mean creating scene on disk outside of unity, or pulling non-imported scene file from source, those will still have to be explicitly imported in scene import popup.
* **Blacklisted scenes**, specifies blacklisted scenes or folders. Any scenes found at path, or inside subfolders of path, will never be automatically imported, and ASM will not include them in import popup.
* **Generate profiles and scenes to**, specifies the path ASM will generate ASM assets to, if you do not wish to generate them to the default path. This only affects where ASM will put the assets on generation, you will still have to move the assets manually, which is fine to do, to be clear, ASM keeps and internal list of its own assets by reference, so you can move them wherever you want.
## Editor page

![](../image/settings-editor-page.png)

The editor page contains:
* **Force profile**, specifies a profile that is force enabled, useful for teams that wish to have only one person manage ASM.
* **Default profile**, specifies a default profile that will be enabled whenever ASM cannot find an active profile during editor initialization.
* **Run ASM startup process when using collection play button**, specifies whatever ASM should run startup process before opening collection when pressing collection play button.
* **Open collection when opening SceneAsset**, specifies that, *in editor*, that when double clicking a scene, ASM should open the first collection found that the scene is contained within, instead of just opening the scene on its own.
* **Allow locking collections**, specifies that a lock symbol should be shown in collection settings. When locked, a collection becomes read-only. *Only applied to Scene manager window UI, not when editing values directly on scriptable objects, or in notepad or git for example.*
* **Allow locking scenes**, specifies that a lock symbol should be shown in scene hierarchy. When locked, and user attempts to save after modifying it, a prompt will popup asking to save to a new file, or to cancel. *Only applied when saving normally, no effect when modifying scene file in notepad for example, or pulling from git.*
* Display:
	* **Play button**, specifies whatever collection play buttons should be visible.
	* **Open button**, specifies whatever collection open buttons should be visible.
	* **Open additive button**, specifies whatever collection open additive buttons should be visible.
	* **Display play button in toolbar**, *hidden unless [marijnz/unity-toolbar-extender](https://github.com/marijnz/unity-toolbar-extender) package is installed*, displays an ASM play button in the toolbar, next to the regular play button.
* Logging:
	* **Asset import**, displays a log message when an ASM asset is imported, or un-imported.
	* **Scene loading**, displays a log message when a scene is loaded, or unloaded.
	* **Open scene tracking**, displays a log message when a scene is tracked, or untracked.
	* **Startup**, displays log messages when running startup.
	* **Scene operations**, displays log messages when a scene operations are busy.
	* **Build scene list updated**, displays a log message when build scene list is updated.

> The logging messages are only used to debug, 99% of users do not need to enable these, unless they want to.



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Scene manager.md -->

# Scene manager

The scene manager class is meant to act as the the core API of ASM, and provides access to the most important systems within.

> There are also a lot miscellaneous static utility classes in AdvancedSceneManager.Utility that are not accessible from SceneManager.

> Note when coming from 1.9:\
> ASM 1.9 had multiple scene managers, these has been merged into one, SceneManager.runtime.

## SceneManager.assets
Provides access to ASM asset lists, which would be:
* Collections
* Scenes
* Collection templates
* Default scenes
```csharp
//Gets all level scenes
SceneManager.assets.scenes.Where(s => s.name.StartsWith("Level")).ToArray();
```

## SceneManager.openScenes
Provides access to the list of open scenes.\
Proxy for: `SceneManager.runtime.openScenes`.

## SceneManager.openCollection
Provides access to the currently open collection, null if none.\
Proxy for: `SceneManager.runtime.openCollection`.

## SceneManager.preloadedScene
Provides access to the currently preloaded scene, null if none.\
Proxy for: `SceneManager.runtime.preloadedScene`.

## SceneManager.runtime
Provides access to runtime scene management.
```csharp
public SceneCollection collection;

void OpenCollection() =>
	SceneManager.runtime.Open(collection); //Equivalent to: collection.Open();
```

## SceneManager.app
Provides access to application wide ASM stuff. Handles startup and quit.
```csharp
void OpenCollection()
{
	//Register callback that should run before quit
	SceneManager.app.RegisterQuitCallback(SaveBeforeQuit);
	//Fades the screen out, calls SaveBeforeQuit(), then quits game
	SceneManager.app.Quit(); 
}

IEnumerator SaveBeforeQuit()
{
	yield return SaveGameManager.SaveGame(); //Example save code
}
```

## SceneManager.settings
Provides access to ASM settings. 
```csharp
void ToggleWhateverCollectionShouldOpenWhenAContainedSceneIsOpened()
{
	//When a scene is opened, you can optionally have ASM open the entire collection that it is contained within. This is a user scoped / machine setting, it won't be synced to source control. Let's toggle it for fun, why not.
	var currentValue = SceneManager.settings.user.openCollectionOnSceneAssetOpen;
	SceneManager.settings.user.openCollectionOnSceneAssetOpen = !currentValue;
	SceneManager.settings.user.Save();
}
```

## SceneManager.profile
Provides access to the currently active profile, null if none.\
Equivalent to:\
`Profile.current`.

## SceneManager.isInitialized
Gets whatever ASM is initialized after a domain reload. Some api:s may fail if this is false, most notably .assets.

## SceneManager.OnInitialized(Action)
Registers a callback for when ASM is initialized after a domain reload. Callback is called immediately if ASM is already initialized.



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Scene operations.md -->

# Scene operations

A scene operation in ASM is a basically a queued batch operation for opening and closing scenes. 

At its most basic form, it takes a list of scenes to close, and a list of scenes to open. Scenes are then evaluated (*scene must be open to be closed, and must be closed to be opened*), and then closes and opens them.

On top of that you got some bells and whistles, like [loading screens](Loading%20screens.md), [coroutine callbacks](Callbacks.md), [temporary thread priority switching](Scene%20manager%20window.md#collection-popup), and [automatically unloading unused assets](Scene%20manager%20window.md#collection-popup). Scene operation will also report overall progress.

Scene operation also supports spam checking, and duplicate checking, preventing button spam for example, though it should be noted that the most fool-proof way is still to disable buttons or similar.

## API

Scene operations is the core level API in ASM, all other functions use it, more information about the different layers of APIs here:\
[An overview of ASM API structure](An%20overview%20of%20ASM%20API%20structure.md)

An operation can be started in code by using either of these two:\
`SceneOperation.Queue()`\
`SceneOperation.Start() //Ignores queue`

```csharp
public Scene[] scenesToOpen;
public Scene loadingScene;

public void OnButtonClick() =>
	SceneOperation.Queue().
		Open(sceneToOpen).
		Close(SceneManager.openScenes).
		With(loadingScene);
```

### Fluent API

As you can also see above, SceneOperation supports a fluent API, allowing for things like this:

```csharp

SceneManager.runtime.Open(sceneToOpen).Close(closeAlreadyOpenScene).With(loadingScreenScene);

//This is functionally equivalent to above
sceneToOpen.Open().Close(closeAlreadyOpenScene).With(loadingScreenScene);

```

> You should have a look at `.With(..)` using intellisense, or in the [api documentation](../api/Core.SceneOperation.md), it has many overloads for various different things.

### Callbacks

Scene operations supports callbacks, not only [scene callbacks](Callbacks.md), but also direct callbacks.\
The are called Event Callbacks, and can be registered either on specific scene operations, or globally. 

```csharp
//Called for every operation until domain reload, or explicitly unregistered
//Phase events are available for operation specific API as well  
public static void RegisterGlobalEvents()
{
	//All events are available both globally and specific scene operation instances

	//Phase events
	//Are always called
	SceneManager.runtime.RegisterCallback<StartPhaseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<EndPhaseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<LoadingScreenOpenPhaseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<SceneClosePhaseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<SceneOpenPhaseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<ScenePreloadPhaseEvent>(Callback);

	//Conditional events.
	//Called for each individual scene or collection, if any
	SceneManager.runtime.RegisterCallback<ScenePreloadEvent>(Callback);
	SceneManager.runtime.RegisterCallback<SceneOpenEvent>(Callback);
	SceneManager.runtime.RegisterCallback<SceneCloseEvent>(Callback);
	SceneManager.runtime.RegisterCallback<CollectionOpenEvent>(Callback);
	SceneManager.runtime.RegisterCallback<CollectionCloseEvent>(Callback);
}
```

Read more [here](Callbacks.md#event-callback-api)

## Flags

Using flags helps reduce overhead caused by coroutines in ASM, such as yield return null, which skips a frame. 

Flags allow you to disable certain overhead functions, resulting in faster scene loading. For instance, with an empty scene, using Flags.None could reduce load time from 11 frames to 4 frames. Typically, this performance improvement won't affect your gameplay experience.

> Note: cross scene ref does not work if callbacks are disabled atm.

```csharp
public class SceneLoader : MonoBehaviour
{
    [SerializeField] private Scene sceneToLoad;
    [SerializeField] private SceneCollection collectionToLoad;

    SceneOperationFlags NoFlags = SceneOperationFlags.None;

    SceneOperationFlags AllFlags = SceneOperationFlags.All;

    // Combined flags
    SceneOperationFlags SomeFlags = SceneOperationFlags.CollectionCallbacks | SceneOperationFlags.SceneCallbacks;

    // All but not SceneCallbacks
    SceneOperationFlags AllButFlags = SceneOperationFlags.All & ~SceneOperationFlags.SceneCallbacks;

    public void LoadSceneWithFlags()
    {
        sceneToLoad.Open().With(NoFlags);
        collectionToLoad.Open().With(NoFlags);
    }
}
```


## Order of operations

* Loading screen open
* `ICollectionClose` (_if collection specified_)
* `ISceneClose`
* Unload scenes
* Load scenes
* Preload scene (_if one defined_)
* `ISceneOpen`
* `ICollection` open (_if collection specified_)
* Hide loading screen



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Scenes.md -->

# Scenes

Scenes in ASM are represented as [ScriptableObjects](https://docs.unity3d.com/Manual/class-ScriptableObject.html), providing a convenient drag-and-drop interface for scene references.

## Accessing ASM Scene References

If you only have a Unity `Scene` struct and need to retrieve the ASM `Scene` object, use any of the following:

```csharp
public class Test : MonoBehaviour
{
    void Start()
    {
        var scene1 = this.ASMScene();
        var scene2 = this.gameObject.ASMScene();
        var scene3 = this.gameObject.scene.ASMScene();

        if (this.ASMScene(out var scene4))
        { }

        var activeScene = SceneManager.runtime.activeScene;
    }
}
```

## Drag-and-Drop Use Cases

- Add or replace scenes in a collection
 ![](../image/drop-area.png)
    
- Assign to UnityEvents (e.g., Button → OnClick)
  ![](../image/button-click-scene-open.png)
    
- Reference in scripts:
```csharp
using AdvancedSceneManager.Models;

public class OpenScene
{
    public Scene scene;

    public void Open()
    {
        scene.Open();
    }
}
```

> ❗ **Methods prefixed with ****`_`** are intended for use in UnityEvents. This is because UnityEvents do not support methods with return values or multiple parameters. Prefixed and non-prefixed methods are otherwise identical and kept in sync for consistency.

## Importing Scenes

Scenes must be imported before they can be used in ASM. This is done via the **import prompt** in the Scene Manager window:
![](../image/scene-import-notification.png)
![](../image/import-scene-popup.png)

You can exclude scenes via the blacklist feature (configurable later in settings):
![](../image/blacklist.png)
## Persistent Scenes

A **persistent scene** remains open when switching collections. Enable this in the scene popup. This is useful for UI overlays, managers, and persistent objects.

## Preloading

Preloading allows scenes to be loaded in the background and activated later. ASM supports **multiple preloaded scenes**, assuming Unity allows it.

Example:

```csharp
public class PreloadTrigger : MonoBehaviour
{
    public Scene sceneToPreload;

    void OnTriggerEnter(Collider other)
    {
        if (!sceneToPreload.isOpen && !sceneToPreload.isPreloaded)
            sceneToPreload.Preload();
    }

    void OnTriggerExit(Collider other)
    {
        if (sceneToPreload.isPreloaded)
            SceneManager.runtime.CancelPreload();
    }

    public void FinishPreload()
    {
        if (sceneToPreload.isPreloaded)
            SceneManager.runtime.FinishPreload();
    }
}
```

Use `SceneManager.preloadedScenes` to retrieve currently preloaded scenes.

## Scene Load Priority

Each scene can be assigned a **load priority**, which maps to `Application.backgroundLoadingPriority`. This setting affects the background loading behavior and system thread priority used when loading the scene. It is useful for optimizing loading times in large projects for large scenes, or loading scenes in the background.

## Scene Loaders

ASM supports different loaders depending on how scenes should be handled:

- **RuntimeSceneLoader** – Standard Unity scene loading (default scene loader).
    
- **EditorSceneLoader** – Editor-specific loader (used outside of playmode).
    
- **AddressablesSceneLoader** – Uses Addressables API (requires Addressables package).
    
- **NetcodeSceneLoader** – For use with Unity NGO (requires Netcode for GameObjects package).

The loader assigned to a scene can be toggled via the **Scene Popup** in the Scene Manager window.

> The required package must be installed for a loader to be assignable.

![](../image/addressable-toggle.png)

ASM also supports custom loaders. These can be implemented and registered to support specialized loading behavior. Learn how to create one in the [Scene Loaders guide](scene%20loaders.md).
## Input Bindings

Scenes can be opened via input using scene bindings, just like collections. Bind a key such as `Escape` or `Tab` to toggle UI scenes like pause menus.

## Startup Scenes

Standalone scenes can be marked to open during **startup**, independently of collections. These are opened **after** collections are opened, making them ideal for persistent UI, background managers, or debug overlays.

## Scene Tracking

ASM automatically tracks scenes when opened through its API. In rare integration cases (e.g., with a network scene manager), you may need to track scenes manually:

```csharp
SceneManager.runtime.Track(scene, unityScene);
SceneManager.runtime.Untrack(scene);
```

When a scene is open, but untracked, an indicator will be shown in the hierarchy, when in the editor. This may happen temporarily, and then resolve itself a moment later. This is, in most cases, by design. It is during prolonged cases when it may be a bug, or conflict with another scene manager.
![](../image/untracked-scenes.png)
## Scene Merging and Splitting

Merge scenes via right-click in the scene manager window:
![](../image/scene-context-menu.png)

Split GameObjects into new scenes via the hierarchy context menu:
![](../image/scene-split-menu.png)

Or via code:
```csharp
SceneUtility.MergeScenes(targetScene, scenesToMerge); // Editor only
SceneUtility.MoveToNewScene(gameObject);              // Editor only
```



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Splash screens.md -->

# Splash Screens

Splash screens in **Advanced Scene Manager (ASM)** are loading screens that appear at the very beginning of startup, before any other scenes are loaded. They use the same system as other loading screens but are shown during startup, as all startup collections and standalone startup scenes are opened.

Splash scenes can be assigned in the **ASM Startup Settings**.

### Default splash scenes

ASM includes **two default splash screens**:
- **Splash ASM** – Displays a logo and background
- **Splash Fade** – An empty scene that simply fades in/out.

These default splash screens are included in the **UPM sample package**. You can import them from the **Package Manager** window or via the **Import** button in the ASM defaults collection UI—just like the default loading screens.

## Creating a Custom Splash Screen

Custom splash screens are created by inheriting from `AdvancedSceneManager.Callbacks.SplashScreen`.

```csharp
public class MySplashScreen : SplashScreen
{
    public CanvasGroup fadeGroup;
    public float fadeDuration = 1f;

    public override IEnumerator OnOpen() => FadeIn();

    public override IEnumerator OnClose() => FadeOut();

    protected IEnumerator FadeIn()
    {
        if (fadeDuration > 0)
            yield return fadeGroup.Fade(1, fadeDuration);
        else
            fadeGroup.alpha = 1;
    }

    protected IEnumerator FadeOut()
    {
        yield return fadeGroup.Fade(0, fadeDuration);
    }

    // Optional: You can override OnProgressChanged as well, just like loading screens
}
```

Once your script is ready:

1. Place it in a dedicated scene.
2. Assign the scene as the splash screen under **ASM Settings > Startup**.
    
> **Note:** Splash screens and loading screens cannot coexist in the same scene.

> **Note:** For a scene to be recognized as a splash screen, ASM relies on a serialized flag inside the scene file. This flag is set by the `SplashScreen` base class:
> ```csharp
> [SerializeField]
> private bool isSplashScreen = true;
> 
> public virtual void OnValidate()
> {
>     if (!isSplashScreen)
>         isSplashScreen = true;
> }
> ```
> This flag (`isSplashScreen: 1`) must be written into the scene file on disk. That only happens if the scene is marked as dirty and saved afterward. So if your custom splash screen doesn't show up in splash scene pickers, try modifying and saving the scene again.
> 
> Additionally, ASM maintains a cached `isSplashScreen` flag on its internal Scene Scriptable Objects. This cache may become outdated. You can manually refresh all scene metadata by pressing the **reload** button next to the loading scene pickers in the UI. This forces ASM to scan scene files on disk and update flags accordingly.

---

## Progress Feedback (Optional)

Splash screens may optionally display progress using the same `ILoadProgressData` interface as loading screens:

```csharp
public override void OnProgressChanged(ILoadProgressData progress)
{
    // Example: update slider or UI element
    mySlider.value = progress.value;
}
```

ASM will automatically send progress updates if the splash screen remains open during early operations.

## Accessing Default Splash Screens via Code

ASM exposes references to the default splash screens:

```csharp
SceneManager.assets.defaults.splashASMScene
SceneManager.assets.defaults.splashFadeScene
```



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Standalone scenes.md -->

# Standalone Scenes

Standalone scenes are scenes that aren't part of any scene collection but should still be included in the build. These scenes are managed via a special dynamic collection in ASM called the **Standalone** collection.

This collection ensures that such scenes are tracked and included in builds, even though they are not tied to a specific group.

![](../image/scene-manager-window-dynamic-collections.png)
## Startup Behavior

Standalone scenes can be configured to open during game startup or when entering play mode in the editor. These settings are controlled through the **Scene Menu**, accessible via the menu button on the scene field.

![](../image/standalone-options.png)

To configure startup behavior:

1. Click the menu button next to the standalone scene field.
2. Select the desired startup option:
   - **Open**: Always opens on startup.
   - **Auto**: Opens if no other startup scenes override it.
   - **Do Not Open**: Never opens automatically.

> These startup settings are especially useful for utility scenes such as overlays, persistent UI, or manager systems.
## Input Bindings

Standalone scenes support [scene bindings](Scene%20bindings.md), allowing them to be opened and closed in response to user input.

This makes them ideal for UI elements like pause menus, scoreboards, or debug windows—any content that you may want to toggle using keys like Escape or Tab.

![](../image/scene-bindings.png)

To bind a key to a standalone scene:
1. Open the scene menu.
2. Scroll to the **Input Binding** section.
3. Select your key and interaction mode:
   - **Open**: Opens scene, doesn't close it.
   - **Hold**: Opens while the key is held, closes on release.
   - **Toggle**: Opens or closes on each press.
## Usage Notes

- The standalone collection cannot be deleted and is always available in every profile.
- Scenes in this collection can be set as **persistent**, meaning they won't close automatically when switching collections.
- Scenes added to the standalone collection are automatically included in build settings—no manual management required.



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Updating.md -->

# Updating Advanced Scene Manager

Advanced Scene Manager follows a versioning system: **Upgrade.Major.Minor/Patch**. Below is an explanation of what each type of update involves and how to handle them.

---

### **Upgrades**
- **What it means:**  
  Upgrades introduce significant changes, often incompatible with work from previous versions.
  
  **Action required:**  
  - These updates require extra care as prior work may not carry over.  

---

### **Major Updates**  
- **What it means:**  
  Major updates often include API changes and may introduce breaking changes. 
  You will not lose your profiles, collections, or imported scenes.

  **Action required:**  
  - **Backup First:** Save your project to Git (or another version control system) before proceeding.  
  - **Uninstall Old Versions:**  
    - Locate ASM in the **Package Manager** under **"Packages - Lazy Solutions"**.  
    - ASM may also appear under **"Packages - Asset Store"**. Remove ASM under **"Packages - Lazy Solutions"**.
  
  ![](/image/ASM-PackageManager.png)  

---

### **Minor/Patch Updates**  
- **What it means:**  
  Patches resolve bugs or other issues or contains minor improvements.
  Patches installed outside of asset store are usually not as tested.

  **Action required:**  
  - No need to uninstall ASM for patches.  
  - **Where to download patches:**  
    - Available on GitHub and Discord.  
    - Alternatively, install patches directly through ASM settings in Unity.  

---

By following these guidelines, you can ensure a smooth update process while keeping your work safe.



<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/Videos.md -->

# Advanced Scene Manager - Video Tutorials

Discover how **Advanced Scene Manager** can simplify your Unity projects. Watch these tutorials to see it in action and learn how to get started!

---

## 📹 Getting Started with Advanced Scene Manager

Learn the basics of setting up and using Advanced Scene Manager in your Unity projects.

[![Getting Started with Advanced Scene Manager](https://img.youtube.com/vi/H-9FFJ7cLnc/0.jpg)](https://youtu.be/H-9FFJ7cLnc)

---

## 📹 Creating Loading Screens



[![Creating Loading Screens](https://img.youtube.com/vi/MiXD2jrAqoo/0.jpg)](https://youtu.be/MiXD2jrAqoo)

---




<!-- https://github.com/Lazy-Solutions/AdvancedSceneManager/blob/main/docs/guides/addressables.md -->

# Addressables

When [addressables](https://docs.unity3d.com/Manual/com.unity.addressables.html) package is installed, ASM will automatically switch to using the addressables API for opening and closing scenes for scenes specified as addressable. Scenes can be flagged as addressable in the [scene popup](Scene%20manager%20window.md#scene-popup), both collection scenes and standalone scenes can be flagged.

[Collection popup](Scene%20manager%20window.md#collection-popup) has a toggle, which will toggle all scenes within.

> When ASM adds a [scene](Scenes.md) to addressables, it will add it under a default group, named after the [collection](Scene%20collections.md) the [scene](Scenes.md) is contained in. This group will not have a schema assigned to it by ASM, and is expected to be assigned manually, or have all scenes reassigned to other groups.

![](../image/addressable-toggle.png)




